Index: dictionary_palindrome.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/dictionary_palindrome.py b/dictionary_palindrome.py
new file mode 100644
--- /dev/null	(date 1748238969002)
+++ b/dictionary_palindrome.py	(date 1748238969002)
@@ -0,0 +1,35 @@
+from datetime import datetime
+from Palindromes import is_palindrome
+
+start_time = datetime.now()
+
+_crypt_toll = 0
+_total_grants = 13
+
+codeword_map = {
+    1: 'EchoOne', 2: 'Phantom2', 3: 'Cipher3', 4: 'NodeFour',
+    5: 'DeltaFive', 6: 'HexaSix', 7: 'Sev3nKey', 8: 'OctoShade',
+    9: 'NinerRun', 10: 'TenFold', 11: 'Prime11', 12: 'TwelveX', 13: 'Red13',
+}
+
+test_cases = [
+    ("racecar", True, 2),
+    ("hello", False, 2),
+    ("A man, a plan, a canal, Panama", True, 3),
+    ("Doc, note I dissent. A fast never prevents a fatness. I diet on cod.", True, 3),
+    ("Are we not pure? “No sir!” Panama’s moody Noriega brags. “It is garbage!” Irony dooms a man — a prisoner up to new era", True, 3)
+]
+
+for text, expected, mk in test_cases:
+    result = is_palindrome(text)
+    if result == expected:
+        print(f"✓ Test passed for: '{text[:30]}...' (+{mk})")
+        _crypt_toll += mk
+    else:
+        print(f"✗ Test failed for: '{text[:30]}...'")
+
+end_time = datetime.now()
+
+print(f"\nTest session started at: {start_time.strftime('%H:%M:%S')}")
+print(f"Test session ended at: {end_time.strftime('%H:%M:%S')}")
+print(f"Access Code: {codeword_map.get(_crypt_toll, 'Unclassified')}")
Index: Stacks_llists.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Stacks_llists.py b/Stacks_llists.py
new file mode 100644
--- /dev/null	(date 1748370384781)
+++ b/Stacks_llists.py	(date 1748370384781)
@@ -0,0 +1,57 @@
+# Stack implementation using linked list is conceptual for large data
+# As it only allocates memory when needed, hence reducing on memory wastage
+
+
+
+class StackNode:   #Node for linked list
+    def _init_(self,value):
+        self.value = value
+        self.next = None
+
+# Stack implemented with linked lists
+class LinkedListStack:
+    def _init_(self):
+        self.top = None  #as the stack is empty
+
+    def is_empty(self):
+        return self.top is None
+
+    def push(self,value): #creating a new node
+        new_node = StackNode(value) #create
+        new_node.next = self.top #new node pointer -> current top node
+        self.top = new_node #top pointer -> new node (as it is the new top of the stack)
+
+    def pop(self):
+        if self.is_empty():
+            raise Exception("Cannot pop an empty stack!")
+
+        popped_value = self.top.value
+        self.top = self.top.next  #Moving the top pointer to next node down the stack
+        return popped_value
+
+    def peek(self):
+        if self.is_empty():
+            raise Exception("Cannot peek an empty stack!")
+        return self.top.value
+
+    def display(self):
+        current = self.top
+        values = []
+        while current:
+            values.append(str(current.value))
+            current = current.next
+        print("Stack from top to bottom:", "->".join(values))
+
+
+if __name__=="main_":
+        stack_11 = LinkedListStack()
+        stack_11.push(5)
+        stack_11.push(10)
+        stack_11.push(15)
+
+        stack_11.display()
+
+        print("Peek top:", stack_11.peek())
+
+        print("Pop:", stack_11.pop())
+        stack_11.display()
\ No newline at end of file
